package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/fatih/color"
	"github.com/spf13/cobra"

	"github.com/kjourdan1/lzctl/internal/config"
	"github.com/kjourdan1/lzctl/internal/output"
)

var docsCmd = &cobra.Command{
	Use:   "docs",
	Short: "Generate project documentation from lzctl.yaml",
	Long: `Produces documentation artifacts from the project configuration:

  - README.md â€“ project overview, platform layers, landing zones

Examples:
  lzctl docs
  lzctl docs --output docs/generated/`,
	RunE: runDocs,
}

var (
	docsOutputDir string
)

func init() {
	docsCmd.Flags().StringVar(&docsOutputDir, "output", "", "custom output directory (default: docs/generated)")
	rootCmd.AddCommand(docsCmd)
}

func runDocs(cmd *cobra.Command, args []string) error {
	output.Init(verbosity > 0, jsonOutput)

	root, err := absRepoRoot()
	if err != nil {
		return err
	}
	bold := color.New(color.Bold)
	green := color.New(color.FgGreen, color.Bold)

	// Load project config.
	cfg, err := configCache()
	if err != nil {
		return fmt.Errorf("load config: %w (run lzctl init first)", err)
	}

	bold.Fprintf(os.Stderr, "ðŸ“„ Generating docs for project: %s\n\n", cfg.Metadata.Name)

	outDir := docsOutputDir
	if outDir == "" {
		outDir = filepath.Join(root, "docs", "generated")
	}
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	// Generate README.md
	readmePath := filepath.Join(outDir, "README.md")
	readme := generateReadme(cfg, root)
	if err := os.WriteFile(readmePath, []byte(readme), 0o644); err != nil {
		return fmt.Errorf("write README: %w", err)
	}

	green.Fprintf(os.Stderr, "  âœ… %s\n", readmePath)
	fmt.Fprintln(os.Stderr)
	green.Fprintln(os.Stderr, "âœ… Documentation generation complete.")

	return nil
}

func generateReadme(cfg *config.LZConfig, root string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("# %s â€“ Azure Landing Zone\n\n", cfg.Metadata.Name))
	sb.WriteString("Generated by `lzctl docs`.\n\n")
	sb.WriteString("## Project Overview\n\n")
	sb.WriteString("| Property | Value |\n")
	sb.WriteString("|----------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Tenant | %s |\n", cfg.Metadata.Tenant))
	sb.WriteString(fmt.Sprintf("| Primary Region | %s |\n", cfg.Metadata.PrimaryRegion))
	sb.WriteString(fmt.Sprintf("| Connectivity | %s |\n", cfg.Spec.Platform.Connectivity.Type))
	sb.WriteString(fmt.Sprintf("| CI/CD | %s |\n", cfg.Spec.CICD.Platform))
	sb.WriteString(fmt.Sprintf("| Landing Zones | %d |\n\n", len(cfg.Spec.LandingZones)))

	// Platform layers
	layers, _ := resolveLocalLayers(root, "")
	if len(layers) > 0 {
		sb.WriteString("## Platform Layers\n\n")
		for _, layer := range layers {
			sb.WriteString(fmt.Sprintf("- `%s`\n", layer))
		}
		sb.WriteString("\n")
	}

	// Landing zones
	if len(cfg.Spec.LandingZones) > 0 {
		sb.WriteString("## Landing Zones\n\n")
		sb.WriteString("| Name | Archetype | Subscription |\n")
		sb.WriteString("|------|-----------|--------------|\n")
		for _, lz := range cfg.Spec.LandingZones {
			sub := "(pending)"
			if lz.Subscription != "" {
				sub = lz.Subscription
			}
			sb.WriteString(fmt.Sprintf("| %s | %s | %s |\n", lz.Name, lz.Archetype, sub))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("## Quick Start\n\n")
	sb.WriteString("```bash\nlzctl plan          # Preview changes\nlzctl apply         # Deploy platform layers\nlzctl status        # Show current state\nlzctl drift         # Detect configuration drift\n```\n")

	return sb.String()
}
