package importer

import (
	"fmt"
	"regexp"
	"strings"
)

// GeneratedFile represents a single file produced by the HCL generator.
type GeneratedFile struct {
	Path    string
	Content string
}

// HCLGenerator produces Terraform import blocks and resource configurations
// for importable Azure resources.
type HCLGenerator struct{}

// NewHCLGenerator creates a new HCL generator.
func NewHCLGenerator() *HCLGenerator {
	return &HCLGenerator{}
}

// GenerateAll produces import blocks and HCL resource stubs for the given resources.
// Resources are grouped by layer when possible.
func (g *HCLGenerator) GenerateAll(resources []ImportableResource, targetDir string) []GeneratedFile {
	if len(resources) == 0 {
		return nil
	}

	grouped := g.groupByLayer(resources)
	files := make([]GeneratedFile, 0, len(grouped)*2)

	for layer, layerResources := range grouped {
		importContent := g.renderImportBlocks(layerResources)
		hclContent := g.renderResourceBlocks(layerResources)

		basePath := targetDir
		if layer != "general" {
			basePath = fmt.Sprintf("%s/%s", targetDir, layer)
		}

		files = append(files, GeneratedFile{
			Path:    fmt.Sprintf("%s/import.tf", basePath),
			Content: g.fileHeader() + importContent,
		})
		files = append(files, GeneratedFile{
			Path:    fmt.Sprintf("%s/resources.tf", basePath),
			Content: g.fileHeader() + hclContent,
		})
	}

	return files
}

// GenerateImportBlock produces a single Terraform import block string.
func (g *HCLGenerator) GenerateImportBlock(resource ImportableResource) string {
	if !resource.Supported {
		return fmt.Sprintf("# TODO: manual import required for %s %q\n", resource.AzureType, resource.Name)
	}
	addr := g.terraformAddress(resource)
	return fmt.Sprintf("import {\n  to = %s\n  id = %q\n}\n", addr, resource.ID)
}

// GenerateResourceBlock produces a stub HCL resource configuration.
func (g *HCLGenerator) GenerateResourceBlock(resource ImportableResource) string {
	if !resource.Supported {
		return fmt.Sprintf("# TODO: manual import required for %s %q\n# Azure Resource ID: %s\n",
			resource.AzureType, resource.Name, resource.ID)
	}

	localName := g.localName(resource)
	attrs := g.resourceAttributes(resource)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource %q %q {\n", resource.TerraformType, localName))
	for _, attr := range attrs {
		sb.WriteString(fmt.Sprintf("  %s\n", attr))
	}
	sb.WriteString("}\n")
	return sb.String()
}

func (g *HCLGenerator) fileHeader() string {
	return "# Generated by lzctl import â€” review before applying\n# Run `terraform plan` to verify zero-diff after import\n\n"
}

func (g *HCLGenerator) renderImportBlocks(resources []ImportableResource) string {
	var sb strings.Builder
	for _, r := range resources {
		sb.WriteString(g.GenerateImportBlock(r))
		sb.WriteString("\n")
	}
	return sb.String()
}

func (g *HCLGenerator) renderResourceBlocks(resources []ImportableResource) string {
	var sb strings.Builder
	for _, r := range resources {
		sb.WriteString(g.GenerateResourceBlock(r))
		sb.WriteString("\n")
	}
	return sb.String()
}

// groupByLayer maps resources to CAF layers based on their Azure type.
func (g *HCLGenerator) groupByLayer(resources []ImportableResource) map[string][]ImportableResource {
	grouped := make(map[string][]ImportableResource)
	for _, r := range resources {
		layer := g.inferLayer(r.AzureType)
		grouped[layer] = append(grouped[layer], r)
	}
	return grouped
}

func (g *HCLGenerator) inferLayer(azureType string) string {
	normalized := strings.ToLower(azureType)
	switch {
	case strings.Contains(normalized, "microsoft.management"):
		return "management-groups"
	case strings.Contains(normalized, "microsoft.network"):
		return "connectivity"
	case strings.Contains(normalized, "microsoft.authorization"):
		return "governance"
	case strings.Contains(normalized, "microsoft.managedidentity"):
		return "identity"
	case strings.Contains(normalized, "microsoft.operationalinsights"),
		strings.Contains(normalized, "microsoft.automation"):
		return "management"
	default:
		return "general"
	}
}

func (g *HCLGenerator) terraformAddress(resource ImportableResource) string {
	return fmt.Sprintf("%s.%s", resource.TerraformType, g.localName(resource))
}

var nonAlphanumUnderscore = regexp.MustCompile(`[^a-z0-9_]+`)

func (g *HCLGenerator) localName(resource ImportableResource) string {
	name := strings.ToLower(strings.TrimSpace(resource.Name))
	name = strings.ReplaceAll(name, "-", "_")
	name = nonAlphanumUnderscore.ReplaceAllString(name, "")
	if name == "" {
		name = "imported"
	}
	return name
}

// resourceAttributes returns stub HCL attributes for a given resource type.
func (g *HCLGenerator) resourceAttributes(resource ImportableResource) []string {
	common := []string{
		fmt.Sprintf("name     = %q", resource.Name),
	}

	if resource.ResourceGroup != "" && resource.TerraformType != "azurerm_resource_group" {
		common = append(common, fmt.Sprintf("resource_group_name = %q", resource.ResourceGroup))
	}

	switch resource.TerraformType {
	case "azurerm_resource_group":
		return append(common, "location = \"westeurope\" # TODO: verify actual location")

	case "azurerm_virtual_network":
		return append(common,
			"location            = \"westeurope\" # TODO: verify actual location",
			"address_space       = [\"10.0.0.0/16\"] # TODO: verify actual address space",
		)

	case "azurerm_subnet":
		return append(common,
			"virtual_network_name = \"\" # TODO: set parent VNet name",
			"address_prefixes     = [\"10.0.0.0/24\"] # TODO: verify actual prefix",
		)

	case "azurerm_network_security_group":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_route_table":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_key_vault":
		return append(common,
			"location            = \"westeurope\" # TODO: verify actual location",
			"tenant_id           = \"\" # TODO: set tenant ID",
			"sku_name            = \"standard\" # TODO: verify actual SKU",
		)

	case "azurerm_storage_account":
		return append(common,
			"location                 = \"westeurope\" # TODO: verify actual location",
			"account_tier             = \"Standard\" # TODO: verify actual tier",
			"account_replication_type = \"LRS\" # TODO: verify actual replication",
		)

	case "azurerm_user_assigned_identity":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_subscription_policy_assignment":
		return append(common,
			"policy_definition_id = \"\" # TODO: set policy definition ID",
			"subscription_id      = \"\" # TODO: set subscription ID",
		)

	default:
		return append(common, "# TODO: add required attributes for this resource type")
	}
}
