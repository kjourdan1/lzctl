package importer

import (
	"fmt"
	"regexp"
	"strings"
)

// GeneratedFile represents a single file produced by the HCL generator.
type GeneratedFile struct {
	Path    string
	Content string
}

// HCLGenerator produces Terraform import blocks and resource configurations
// for importable Azure resources.
type HCLGenerator struct{}

// NewHCLGenerator creates a new HCL generator.
func NewHCLGenerator() *HCLGenerator {
	return &HCLGenerator{}
}

// GenerateAll produces import blocks and HCL resource stubs for the given resources.
// Resources are grouped by layer when possible.
func (g *HCLGenerator) GenerateAll(resources []ImportableResource, targetDir string) []GeneratedFile {
	if len(resources) == 0 {
		return nil
	}

	grouped := g.groupByLayer(resources)
	files := make([]GeneratedFile, 0, len(grouped)*2)

	for layer, layerResources := range grouped {
		importContent := g.renderImportBlocks(layerResources)
		hclContent := g.renderResourceBlocks(layerResources)

		basePath := fmt.Sprintf("%s/%s", targetDir, layer)

		files = append(files, GeneratedFile{
			Path:    fmt.Sprintf("%s/import.tf", basePath),
			Content: g.fileHeader() + importContent,
		})
		files = append(files, GeneratedFile{
			Path:    fmt.Sprintf("%s/resources.tf", basePath),
			Content: g.fileHeader() + hclContent,
		})
	}

	return files
}

// GenerateImportBlock produces a single Terraform import block string.
func (g *HCLGenerator) GenerateImportBlock(resource ImportableResource) string {
	if !resource.Supported {
		return fmt.Sprintf("# TODO: manual import required for %s %q\n", resource.AzureType, resource.Name)
	}
	addr := g.terraformAddress(resource)
	return fmt.Sprintf("import {\n  to = %s\n  id = %q\n}\n", addr, resource.ID)
}

// GenerateResourceBlock produces a stub HCL resource or AVM module configuration.
// When an AVM module is available for the resource type, a module block is emitted
// instead of a raw resource block — callers should then remove the import block and
// instead run `terraform import module.<name>.<tf_type>.<local> <id>` manually.
func (g *HCLGenerator) GenerateResourceBlock(resource ImportableResource) string {
	if !resource.Supported {
		return fmt.Sprintf("# TODO: manual import required for %s %q\n# Azure Resource ID: %s\n",
			resource.AzureType, resource.Name, resource.ID)
	}

	// Prefer AVM module stub when a module source is available.
	if avm := AVMSource(resource.TerraformType); avm != "" {
		return g.GenerateAVMModuleBlock(resource, avm)
	}

	localName := g.localName(resource)
	attrs := g.resourceAttributes(resource)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("resource %q %q {\n", resource.TerraformType, localName))
	for _, attr := range attrs {
		sb.WriteString(fmt.Sprintf("  %s\n", attr))
	}
	sb.WriteString("}\n")
	return sb.String()
}

// GenerateAVMModuleBlock produces a Terraform module block stub using the AVM
// Registry source. The import block for AVM modules uses the internal resource
// address (module.<name>.<tf_type>.<local_name>).
func (g *HCLGenerator) GenerateAVMModuleBlock(resource ImportableResource, avmSource string) string {
	localName := g.localName(resource)
	attrs := g.avmModuleAttributes(resource)

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# AVM module — lzctl emits a module stub; import via:\n"))
	sb.WriteString(fmt.Sprintf("#   terraform import 'module.%s.<resource_type>.this' %q\n", localName, resource.ID))
	sb.WriteString(fmt.Sprintf("module %q {\n", localName))
	sb.WriteString(fmt.Sprintf("  source  = %q\n", avmSource))
	sb.WriteString(fmt.Sprintf("  version = \"~> 0.1\" # TODO: pin to latest tested version\n"))
	for _, attr := range attrs {
		sb.WriteString(fmt.Sprintf("  %s\n", attr))
	}
	sb.WriteString("}\n")
	return sb.String()
}

func (g *HCLGenerator) avmModuleAttributes(resource ImportableResource) []string {
	base := []string{
		fmt.Sprintf("name                = %q", resource.Name),
		"location            = var.location # TODO: verify",
		fmt.Sprintf("resource_group_name = %q # TODO: verify", resource.ResourceGroup),
	}
	switch resource.TerraformType {
	case "azurerm_key_vault":
		return append(base, "tenant_id = data.azurerm_client_config.current.tenant_id")
	case "azurerm_kubernetes_cluster":
		return append(base,
			"private_cluster_enabled = true # secure-by-default",
		)
	case "azurerm_container_registry":
		return append(base, "sku = \"Premium\" # TODO: verify SKU")
	case "azurerm_api_management":
		return append(base,
			"publisher_name  = \"\" # TODO: set publisher",
			"publisher_email = \"\" # TODO: set publisher email",
			"sku_name        = \"Developer_1\" # TODO: verify SKU",
		)
	default:
		return append(base, "# TODO: add AVM-specific required attributes")
	}
}

func (g *HCLGenerator) fileHeader() string {
	return "# Generated by lzctl import — review before applying\n# Run `terraform plan` to verify zero-diff after import\n\n"
}

func (g *HCLGenerator) renderImportBlocks(resources []ImportableResource) string {
	var sb strings.Builder
	for _, r := range resources {
		sb.WriteString(g.GenerateImportBlock(r))
		sb.WriteString("\n")
	}
	return sb.String()
}

func (g *HCLGenerator) renderResourceBlocks(resources []ImportableResource) string {
	var sb strings.Builder
	for _, r := range resources {
		sb.WriteString(g.GenerateResourceBlock(r))
		sb.WriteString("\n")
	}
	return sb.String()
}

// groupByLayer maps resources to CAF layers based on their Azure type.
func (g *HCLGenerator) groupByLayer(resources []ImportableResource) map[string][]ImportableResource {
	grouped := make(map[string][]ImportableResource)
	for _, r := range resources {
		layer := g.inferLayer(r.AzureType)
		grouped[layer] = append(grouped[layer], r)
	}
	return grouped
}

func (g *HCLGenerator) inferLayer(azureType string) string {
	normalized := strings.ToLower(azureType)
	switch {
	case strings.Contains(normalized, "microsoft.management"):
		return "management-groups"
	case strings.Contains(normalized, "microsoft.network"):
		return "connectivity"
	case strings.Contains(normalized, "microsoft.authorization"):
		return "governance"
	case strings.Contains(normalized, "microsoft.managedidentity"):
		return "identity"
	case strings.Contains(normalized, "microsoft.operationalinsights"),
		strings.Contains(normalized, "microsoft.automation"):
		return "management"
	// Blueprint workload types map to the landing-zone blueprint layer.
	case strings.Contains(normalized, "microsoft.web"),
		strings.Contains(normalized, "microsoft.apimanagement"):
		return "blueprint-paas"
	case strings.Contains(normalized, "microsoft.containerservice"),
		strings.Contains(normalized, "microsoft.containerregistry"),
		strings.Contains(normalized, "microsoft.app/managedenv"),
		strings.Contains(normalized, "microsoft.app/container"):
		return "blueprint-aks"
	case strings.Contains(normalized, "microsoft.desktopvirtualization"):
		return "blueprint-avd"
	default:
		return "general"
	}
}

func (g *HCLGenerator) terraformAddress(resource ImportableResource) string {
	return fmt.Sprintf("%s.%s", resource.TerraformType, g.localName(resource))
}

var nonAlphanumUnderscore = regexp.MustCompile(`[^a-z0-9_]+`)

func (g *HCLGenerator) localName(resource ImportableResource) string {
	name := strings.ToLower(strings.TrimSpace(resource.Name))
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, " ", "_")
	name = nonAlphanumUnderscore.ReplaceAllString(name, "")
	if name == "" {
		name = "imported"
	}
	return name
}

// resourceAttributes returns stub HCL attributes for a given resource type.
func (g *HCLGenerator) resourceAttributes(resource ImportableResource) []string {
	common := []string{
		fmt.Sprintf("name     = %q", resource.Name),
	}

	if resource.ResourceGroup != "" && resource.TerraformType != "azurerm_resource_group" {
		common = append(common, fmt.Sprintf("resource_group_name = %q", resource.ResourceGroup))
	}

	switch resource.TerraformType {
	case "azurerm_resource_group":
		return append(common, "location = \"westeurope\" # TODO: verify actual location")

	case "azurerm_virtual_network":
		return append(common,
			"location            = \"westeurope\" # TODO: verify actual location",
			"address_space       = [\"10.0.0.0/16\"] # TODO: verify actual address space",
		)

	case "azurerm_subnet":
		return append(common,
			"virtual_network_name = \"\" # TODO: set parent VNet name",
			"address_prefixes     = [\"10.0.0.0/24\"] # TODO: verify actual prefix",
		)

	case "azurerm_network_security_group":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_route_table":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_key_vault":
		return append(common,
			"location            = \"westeurope\" # TODO: verify actual location",
			"tenant_id           = \"\" # TODO: set tenant ID",
			"sku_name            = \"standard\" # TODO: verify actual SKU",
		)

	case "azurerm_storage_account":
		return append(common,
			"location                 = \"westeurope\" # TODO: verify actual location",
			"account_tier             = \"Standard\" # TODO: verify actual tier",
			"account_replication_type = \"LRS\" # TODO: verify actual replication",
		)

	case "azurerm_user_assigned_identity":
		return append(common,
			"location = \"westeurope\" # TODO: verify actual location",
		)

	case "azurerm_subscription_policy_assignment":
		return append(common,
			"policy_definition_id = \"\" # TODO: set policy definition ID",
			"subscription_id      = \"\" # TODO: set subscription ID",
		)

	default:
		return append(common, "# TODO: add required attributes for this resource type")
	}
}
